now good, i want to fetch from firebase using react query or useeffect which one is better? remember  I normalized (Course → Modules → Lessons) so they are all document themselves: 

```
yes: here is what i am pushing using normalized structure:
```
import React, { useState } from "react"
import styled from "styled-components"
import { v4 as uuidv4 } from "uuid"
import { Course, Module, Lesson } from "@/types"
import { toast } from "react-toastify"
import { uploadNewCourse } from "@/hooks/courses/uploadCourseWithDetails"

const Container = styled.div`
    max-width: 800px;
    margin: auto;
`
const FormWrapper = styled.div`
    max-width: 800px;
    margin: auto;
    padding: 10px;
`
const TextArea = styled.textarea`
    width: 100%;
    padding: 0.5rem;
    margin: 5px 0;
`
const Divider = styled.hr`
    margin: 10px 0;
`
const Input = styled.input`
    width: 100%;
    margin-top: 5px;
    margin-bottom: 7px;
    padding: 5px;
`
const Button = styled.button<{ disabled?: boolean }>`
    padding: 0.5rem 1rem;
    margin: 0.5rem 0.25rem;
    background: ${({ disabled }) => (disabled ? "#ccc" : "#007bff")};
    color: white;
    border: none;
    border-radius: 4px;
    cursor: ${({ disabled }) => (disabled ? "not-allowed" : "pointer")};

    &:hover {
        background: ${({ disabled }) => (disabled ? "#ccc" : "#0056b3")};
    }
`
// const Button = styled.button`
//     padding: 0.5rem 1rem;
//     margin: 0.5rem 0.25rem;
//     background: #007bff;
//     color: white;
//     border: none;
//     border-radius: 4px;
//     cursor: pointer;

//     &:hover {
//         background: #0056b3;
//     }
// `

export default function CourseUploadForm() {
    const [uploadError, setUploadError] = useState("")
    const [uploading, setUploading] = useState(false)
    const [course, setCourse] = useState<Partial<Course>>({ whatYoullLearn: [] })
    const [newLearningItem, setNewLearningItem] = useState("")
    const [modules, setModules] = useState<(Module & { lessons: Lesson[] })[]>([])
    const [currentModule, setCurrentModule] = useState<Partial<Module>>({
        title: "",
        position: modules.length + 1,
    })
    const [currentLessons, setCurrentLessons] = useState<Partial<Lesson>[]>([])
    const [newLesson, setNewLesson] = useState<Partial<Lesson>>({
        title: "",
        videoUrl: "",
        content: "",
        durationMinutes: 0,
    })

    const [editingModuleIndex, setEditingModuleIndex] = useState<number | null>(null)
    const [editingLessonIndex, setEditingLessonIndex] = useState<number | null>(null)

    const handleCourseChange = (field: keyof Course, value: any) => {
        setCourse((prev) => ({ ...prev, [field]: value }))
    }

    const handleLessonChange = (field: keyof Lesson, value: any) => {
        setNewLesson((prev) => ({ ...prev, [field]: value }))
    }

    const addLessonToCurrentModule = () => {
        if (!newLesson.title) return

        if (editingLessonIndex !== null) {
            const updated = [...currentLessons]
            updated[editingLessonIndex] = newLesson as Lesson
            setCurrentLessons(updated)
            setEditingLessonIndex(null)
        } else {
            setCurrentLessons((prev) => [...prev, newLesson as Lesson])
        }

        setNewLesson({ title: "", videoUrl: "", content: "", durationMinutes: 0 })
    }

    const editLesson = (index: number) => {
        setNewLesson(currentLessons[index])
        setEditingLessonIndex(index)
    }

    const deleteLesson = (index: number) => {
        setCurrentLessons((prev) => prev.filter((_, i) => i !== index))
    }

    const saveCurrentModule = () => {
        if (!currentModule.title) return

        const moduleToSave = {
            ...(currentModule as Module),
            id: currentModule.id || uuidv4(),
            lessons: currentLessons as Lesson[],
        }

        setModules((prev) => {
            if (editingModuleIndex !== null) {
                const updated = [...prev]
                updated[editingModuleIndex] = moduleToSave
                return updated
            } else {
                return [...prev, moduleToSave]
            }
        })

        setCurrentModule({ title: "", position: modules.length + 2 })
        setCurrentLessons([])
        setEditingModuleIndex(null)
    }

    const editModule = (index: number) => {
        const mod = modules[index]
        setEditingModuleIndex(index)
        setCurrentModule({ title: mod.title, position: mod.position, id: mod.id })
        setCurrentLessons(mod.lessons)
    }

    const cancelEdit = () => {
        setCurrentModule({ title: "", position: modules.length + 1 })
        setCurrentLessons([])
        setEditingModuleIndex(null)
        setEditingLessonIndex(null)
    }

    const addLearningItem = () => {
        if (!newLearningItem.trim()) return
        setCourse((prev) => ({
            ...prev,
            whatYoullLearn: [...(prev.whatYoullLearn || []), newLearningItem.trim()],
        }))
        setNewLearningItem("")
    }
    const submitCourse = async () => {
        if (uploading) return
        if (
            !course.title ||
            !course.about ||
            !course.category ||
            !course.skillLevel ||
            !course.facilitatorEmail ||
            !course.image ||
            !course.shortDesc ||
            !course.courseDesc ||
            course.price === undefined ||
            course.onDemandVideos === undefined ||
            !Array.isArray(course.whatYoullLearn)
        ) {
            console.log("Please fill in all required course fields.")
            return
        }
        setUploading(true)
        toast.loading("Uploading the course...")

        try {
            const courseId = uuidv4()

            const finalizedCourse: Course = {
                id: courseId,
                title: course.title,
                category: course.category,
                skillLevel: course.skillLevel,
                facilitatorEmail: course.facilitatorEmail,
                rating: 0,
                image: course.image,
                about: course.about,
                shortDesc: course.shortDesc,
                courseDesc: course.courseDesc,
                students: 0,
                price: course.price,
                onDemandVideos: course.onDemandVideos,
                downloadableFiles: course.downloadableFiles || 0,
                whatYoullLearn: course.whatYoullLearn,
            }

            const finalizedModules = modules.map((mod, modIndex) => ({
                ...mod,
                id: mod.id || uuidv4(),
                position: modIndex,
                lessons: mod.lessons.map((lesson, lessonIndex) => ({
                    ...lesson,
                    id: lesson.id || uuidv4(),
                    position: lessonIndex,
                })),
            }))

            await uploadNewCourse({
                course: finalizedCourse,
                modules: finalizedModules,
                reviews: [],
            })
            toast.dismiss()
            toast.success("Course uploaded successfully!")
        } catch (err) {
            console.error(err)
            toast.error("Failed to upload course.")
        } finally {
            setUploading(false)
            setCourse({ whatYoullLearn: [] })
            setNewLearningItem("")
            setModules([])
            setCurrentModule({ title: "", position: 1 })
            setCurrentLessons([])
            setNewLesson({ title: "", videoUrl: "", content: "", durationMinutes: 0 })
            setEditingModuleIndex(null)
            setEditingLessonIndex(null)
        }
    }
    return (
        <Container>
            <FormWrapper>
                {/* Course Info */}
                <h3>Course Details</h3>
                <Input
                    placeholder="Title"
                    onChange={(e) => handleCourseChange("title", e.target.value)}
                />
                <label htmlFor="category">Category</label>
                <select
                    id="category"
                    value={course.category}
                    onChange={(e) => handleCourseChange("category", e.target.value)}
                >
                    <option value="select">Select</option>
                    <option value="Cryptocurrency">Cryptocurrency</option>
                    <option value="UIUX">UI/UX</option>
                    <option value="Programming">Blockchain Development</option>
                    <option value="Web Development">Web Development</option>
                    <option value="Social Media Marketing">Social Media Marketing</option>
                    <option value="Content Creation">Content Creation</option>
                </select>
                <label htmlFor="skillLevel">Skill Level</label>
                <select
                    id="skillLevel"
                    value={course.skillLevel}
                    onChange={(e) => handleCourseChange("skillLevel", e.target.value)}
                >
                    <option value="select">Select</option>
                    <option value="Beginner">Beginner</option>
                    <option value="Intermediate">Intermediate</option>
                    <option value="Advanced">Advanced</option>
                </select>
                <Input
                    placeholder="Facilitator email"
                    onChange={(e) => handleCourseChange("facilitatorEmail", e.target.value)}
                />
                <Input
                    placeholder="Image URL"
                    onChange={(e) => handleCourseChange("image", e.target.value)}
                />
                <TextArea
                    placeholder="About"
                    onChange={(e) => handleCourseChange("about", e.target.value)}
                />
                <TextArea
                    placeholder="Short Description"
                    onChange={(e) => handleCourseChange("shortDesc", e.target.value)}
                />
                <TextArea
                    placeholder="Full Course Description"
                    onChange={(e) => handleCourseChange("courseDesc", e.target.value)}
                />
                <Input
                    placeholder="Price"
                    type="number"
                    min="0"
                    onChange={(e) => handleCourseChange("price", parseFloat(e.target.value))}
                />
                <Input
                    placeholder="On Demand Videos"
                    type="number"
                    min="1"
                    onChange={(e) => handleCourseChange("onDemandVideos", parseInt(e.target.value))}
                />

                <h3>What You'll Learn</h3>
                <ul>{course.whatYoullLearn?.map((item, index) => <li key={index}>{item}</li>)}</ul>
                <Input
                    placeholder="Add a learning outcome"
                    value={newLearningItem}
                    onChange={(e) => setNewLearningItem(e.target.value)}
                />
                <Button type="button" onClick={addLearningItem}>
                    Add
                </Button>

                <Divider />
                <h3>{editingModuleIndex !== null ? "Edit Module" : "Add Module"}</h3>
                <Input
                    placeholder="Module Title"
                    value={currentModule.title}
                    onChange={(e) =>
                        setCurrentModule((prev) => ({ ...prev, title: e.target.value }))
                    }
                />

                <h3>Lessons</h3>
                {currentLessons.map((lesson, index) => (
                    <div key={index}>
                        <p>
                            {lesson.title} ({lesson.durationMinutes} mins)
                        </p>
                        <Button onClick={() => editLesson(index)}>Edit</Button>
                        <Button onClick={() => deleteLesson(index)}>Delete</Button>
                    </div>
                ))}

                <Input
                    placeholder="Lesson Title"
                    value={newLesson.title}
                    onChange={(e) => handleLessonChange("title", e.target.value)}
                />
                <Input
                    placeholder="Video URL"
                    value={newLesson.videoUrl}
                    onChange={(e) => handleLessonChange("videoUrl", e.target.value)}
                />
                <Input
                    placeholder="Duration (minutes)"
                    type="number"
                    min="1"
                    value={newLesson.durationMinutes?.toString() || ""}
                    onChange={(e) =>
                        handleLessonChange("durationMinutes", parseInt(e.target.value))
                    }
                />
                <TextArea
                    placeholder="Content"
                    value={newLesson.content}
                    onChange={(e) => handleLessonChange("content", e.target.value)}
                />
                <Button type="button" onClick={addLessonToCurrentModule}>
                    {editingLessonIndex !== null ? "Update Lesson" : "Add Lesson"}
                </Button>
                <Button type="button" onClick={saveCurrentModule}>
                    Save Module
                </Button>
                {editingModuleIndex !== null && (
                    <Button type="button" onClick={cancelEdit}>
                        Cancel Editing
                    </Button>
                )}

                <Divider />
                <h3>Saved Modules</h3>
                {modules.map((mod, index) => (
                    <div key={mod.id} className="border p-2 my-2">
                        <strong>{mod.title}</strong> ({mod.lessons.length} lessons)
                        <Button onClick={() => editModule(index)}>Edit</Button>
                    </div>
                ))}

                <Divider />
                <Button onClick={submitCourse} disabled={uploading}>
                    {uploading ? "uploading..." : "Submit Full Course"}
                </Button>
            </FormWrapper>
        </Container>
    )
}
```
upload functionality:
```
import { collection, doc, setDoc, writeBatch, serverTimestamp } from "firebase/firestore"
import { db } from "@/lib/firebase/firebaseConfig"
import { Course, Module, Lesson, Facilitator, Review } from "@/types"

interface UploadCourseInput {
    course: Course
    modules: (Module & { lessons: Lesson[] })[]
    reviews: Review[]
}

export async function uploadNewCourse({ course, modules, reviews }: UploadCourseInput) {
    const batch = writeBatch(db)

    // Create the course document
    const courseRef = doc(db, "courses", course.id)
    batch.set(courseRef, {
        ...course,
        createdAt: serverTimestamp(),
    })

    // Upload modules and nested lessons
    for (const module of modules) {
        const moduleRef = doc(db, "courseModules", `${course.id}_module_${module.id}`)
        batch.set(moduleRef, {
            id: module.id,
            courseId: course.id,
            title: module.title,
            position: module.position,
        })

        for (const lesson of module.lessons) {
            const lessonRef = doc(
                db,
                "courseLessons",
                `${course.id}_module_${module.id}_lesson_${lesson.id}`,
            )
            batch.set(lessonRef, {
                ...lesson,
                courseId: course.id,
                moduleId: module.id,
            })
        }
    }

    // Upload reviews
    for (const review of reviews) {
        const reviewRef = doc(db, "courseReviews", review.id)
        batch.set(reviewRef, {
            ...review,
            createdAt: review.createdAt || serverTimestamp(),
        })
    }

    // Commit all batched writes
    try {
        await batch.commit()
        console.log(" Course uploaded successfully")
    } catch (error) {
        console.error("Failed to upload course:", error)
        throw error
    }
}
```
the types:
```
export interface Course {
    id: string
    title: string
    category: string
    skillLevel: string
    facilitatorEmail: string // link to a facilitator
    rating: number
    image: string
    about: string
    shortDesc: string
    courseDesc: string
    students: number
    price: number
    onDemandVideos: number
    downloadableFiles?: number
    whatYoullLearn: string[]
}
export interface Module {
    id: string
    title: string
    position: number // order of module in course
}
export interface Lesson {
    id: string
    title: string
    videoUrl: string
    content: string
    position: number // order of lesson in module
    durationMinutes: number
    resources?: string[] // optional links or files
}
export interface Review {
    id: string // Firestore document ID (can be same as `${userId}_${courseId}`)
    userId: string
    courseId: string
    stars: number // 1 to 5
    comment: string
    createdAt: string // ISO string or Firestore Timestamp
}
```

import { collection, getDocs, query, where } from "firebase/firestore"
import { db } from "@/lib/firebase/firebaseConfig"
import { Course, Review } from "@/types"

export const fetchCoursesWithReviews = async (): Promise<
    (Course & { reviews: Review[] })[]
> => {
    const courseSnap = await getDocs(collection(db, "courses"))
    const courses = courseSnap.docs.map((doc) => ({
        ...(doc.data() as Course),
        id: doc.id,
    }))

    // Fetch reviews for each course
    const allCoursesWithReviews = await Promise.all(
        courses.map(async (course) => {
            const reviewSnap = await getDocs(
                query(
                    collection(db, "courseReviews"),
                    where("courseId", "==", course.id),
                ),
            )
            const reviews: Review[] = reviewSnap.docs.map((doc) => doc.data() as Review)
            return {
                ...course,
                reviews,
            }
        }),
    )

    return allCoursesWithReviews
}

<Box>
    <Time>
        <StarHalfIcon />
        <span style={{ margin: "10px" }}>
            {course.reviews.length > 0
                ? (
                      course.reviews.reduce(
                          (total, review) => total + review.stars,
                          0,
                      ) / course.reviews.length
                  ).toFixed(1)
                : "0"}
        </span>
    </Time>
</Box>
